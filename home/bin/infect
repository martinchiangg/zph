#!/usr/bin/env ruby

#####
# This file is generated code. DO NOT send patches for it.
#
# Original source files with comments are at:
# https://github.com/csexton/infect
#####


=begin
Content related to pmap belongs to the pmap gem
See source at https://github.com/bruceadams/pmap
License
Copyright 2011 Bruce Adams

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=end
require 'thread' unless defined?(Mutex)

# Global variable for the default thread pool size.
$pmap_default_thread_count ||= 64

module PMap
  class DummyOutput
    def []=(idx, val)
    end
  end

  def self.included(base)
    base.class_eval do
      # Parallel "map" for any Enumerable.
      # Requires a block of code to run for each Enumerable item.
      # [thread_count] is number of threads to create. Optional.
      def pmap(thread_count=nil, &proc)
        in_array = self.to_a        # I'm not sure how expensive this is...
        out_array = Array.new(in_array.size)
        process_core(thread_count, in_array, out_array, &proc)
        out_array
      end

      def process_core(thread_count, in_array, out_array, &proc)
        thread_count = thread_count(thread_count, in_array)
        size = in_array.size

        semaphore = Mutex.new
        index = -1                  # Our use of index is protected by semaphore

        threads = (0...thread_count).map {
          Thread.new {
            i = nil
            while (semaphore.synchronize {i = (index += 1)}; i < size)
              out_array[i] = yield(in_array[i])
            end
          }
        }
        threads.each {|t| t.join}
      end
      private :process_core

      def thread_count(user_requested_count, items)
        user_requested_count ||= $pmap_default_thread_count
        raise ArgumentError, "thread_count must be at least one." unless
          user_requested_count.respond_to?(:>=) && user_requested_count >= 1
        [user_requested_count, items.size].min
      end
      private :thread_count

      # Parallel "each" for any Enumerable.
      # Requires a block of code to run for each Enumerable item.
      # [thread_count] is number of threads to create. Optional.
      def peach(thread_count=nil, &proc)
        process_core(thread_count, self.to_a, DummyOutput.new, &proc)
        self
      end
    end
  end
end

module Enumerable
  include PMap
end

# End of PMap gem

#
# This file is generated code. DO NOT send patches for it.
#
# Original source files with comments are at:
# https://github.com/csexton/infect
#

module Infect
  VERSION = "0.0.5"
end

require 'open-uri'
require 'fileutils'

module Infect
  module Colorize
    def colorize(code, str)
      "\e[#{code}m#{str}\e[0m"
    end
    def notice(str)
      puts colorize(32, str)
    end
    def error(str)
      puts colorize(31, str)
    end
  end
end


require 'open-uri'
require 'fileutils'

module Infect
  class Command
    include Infect::Colorize

    def self.build(command, arg ,opts)
      case command.to_sym
      when :bundle
        Bundle.new(arg, opts)
      else
        $stderr.puts "WARNING: #{command} is not a valid command, ignorning"
      end
    end

    protected

    def mkdir(path)
      expanded_path = File.expand_path(path)
      unless File.directory?(expanded_path)
        notice "Making dir #{path}"
        FileUtils.mkdir_p(expanded_path)
      end
    end

    def chdir(path)
      Dir.chdir(path)
    end

    def download(url, path)
      File.open(File.expand_path(path), "w") do |file|
        open(url) do |read_file|
          file.write(read_file.read)
        end
      end
    end
  end
end

module Infect
  class Command
    class Bundle < Command
      attr_reader :bundle, :name, :location, :options
      def initialize(arg, opts)
        @bundle = arg
        @options = opts
        @name = File.basename(bundle)
        @location = File.expand_path("#{BUNDLE_DIR}/#{name}")
      end

      def url
        "git@github.com:#{bundle}.git"
      end

      def install
        notice "Installing #{name}... "
        mkdir BUNDLE_DIR
        chdir BUNDLE_DIR
        before(options)
        git "clone '#{url}'"
        after(options)
      end

      def update
        notice "Updating #{name}... "
        chdir @location
        before(options)
        git "pull"
        after(options)
      end

      def call
        if File.exists? @location
          update
        else
          install
          after_install(options)
        end
      end

      def before(args=options)
        hook(:before, args)
      end

      def after(args=options)
        hook(:after, args)
      end

      def after_install(args=options)
        hook(:after_install, args)
      end

      def hook(type, args=options)
        return unless args
        script_hook = args.fetch(type) { nil }
        return unless script_hook
        out, status = Open3.capture2(script_hook)
        STDOUT.puts out
      end

      private

      def git(args)
        `git #{args}`
      end
    end
  end
end

require 'fileutils'
module Infect
  class Command
    class Prereqs < Command
      def mkdirs(list)
        list.each do |path|
          FileUtils.mkdir_p(File.expand_path(path))
        end
      end
      def call
        mkdir "~/.vim/bundle"
        if RUBY_PLATFORM =~ /darwin/
          mkdirs %w(~/Library/Vim/swap ~/Library/Vim/backup ~/Library/Vim/undo)
        else
          mkdirs %w(~/.local/share/vim/swap ~/.local/share/vim/backup ~/.local/share/vim/undo")
        end
      end
    end
  end
end

module Infect
  class Cleanup
    include Infect::Colorize
    attr_reader :commands, :force

    def initialize(commands, args = {})
      @commands = commands
      @force = args[:force] || false
    end

    def call
      uninstall_unless_included names
    end

    private

    def uninstall_unless_included(list)
      Dir["#{BUNDLE_DIR}/*"].each do |path|
        unless list.include? File.basename(path)
          if confirm(path)
            notice "Deleting #{path}"
            require 'fileutils'
            FileUtils.rm_rf path
          else
            notice "Leaving #{path}"
          end
        end
      end
    end

    def confirm(name)
      unless force
        print "Remove #{name}? [Yn]: "
        response = STDIN.gets.chomp
        case response.downcase
        when ''
          true
        when 'y'
          true
        else
          false
        end
      end
    end

    def names
      list = []
      commands.each do |command|
        if command.respond_to? :name
          list << command.name
        end
      end
      list
    end

  end
end


require 'shellwords'
require 'open3'

module Infect
  VIMHOME = ENV['VIM'] || "#{ENV['HOME']}/.vim"
  VIMRC = ENV['MYVIMRC'] || "#{ENV['HOME']}/.vimrc"
  BUNDLE_DIR = "#{VIMHOME}/bundle"

  class Runner
    def self.call(*args)
      force = args.include? "-f"

      commands = [Command::Prereqs.new()]

      File.open( VIMRC ).each_line do |line|
        if line =~ /^"=/
          command, arg, opts = parse_command(line.gsub('"=', ''))
          commands << Command.build(command, arg, opts)
        end
      end

      commands.compact.peach(&:call)

      Cleanup.new(commands, :force => force).call

    end

    private

    def self.parse_command(line)

      command, arg, opts_string = line.split ' ', 3
      [command, arg, parse_opts(opts_string)]
    end

    def self.parse_opts(string)
      parts = format_into_hash(string).inject(&:merge)
    end

    def self.format_into_hash(str)
      parts = str.split(",").map(&:strip).reject(&:empty?).map do |i|
        array = i.split("=", 2).map(&:strip)

        Hash[*array].map do |k,v|
          {k.downcase.to_sym => v}
        end.first

require 'thread' unless defined?(Mutex)

# Global variable for the default thread pool size.
$pmap_default_thread_count ||= 64

module PMap
  class DummyOutput
    def []=(idx, val)
    end
  end

  def self.included(base)
    base.class_eval do
      # Parallel "map" for any Enumerable.
      # Requires a block of code to run for each Enumerable item.
      # [thread_count] is number of threads to create. Optional.
      def pmap(thread_count=nil, &proc)
        in_array = self.to_a        # I'm not sure how expensive this is...
        out_array = Array.new(in_array.size)
        process_core(thread_count, in_array, out_array, &proc)
        out_array
      end

      def process_core(thread_count, in_array, out_array, &proc)
        thread_count = thread_count(thread_count, in_array)
        size = in_array.size

        semaphore = Mutex.new
        index = -1                  # Our use of index is protected by semaphore

        threads = (0...thread_count).map {
          Thread.new {
            i = nil
            while (semaphore.synchronize {i = (index += 1)}; i < size)
              out_array[i] = yield(in_array[i])
            end
          }
        }
        threads.each {|t| t.join}
      end
      private :process_core

      def thread_count(user_requested_count, items)
        user_requested_count ||= $pmap_default_thread_count
        raise ArgumentError, "thread_count must be at least one." unless
          user_requested_count.respond_to?(:>=) && user_requested_count >= 1
        [user_requested_count, items.size].min
      end
      private :thread_count

      # Parallel "each" for any Enumerable.
      # Requires a block of code to run for each Enumerable item.
      # [thread_count] is number of threads to create. Optional.
      def peach(thread_count=nil, &proc)
        process_core(thread_count, self.to_a, DummyOutput.new, &proc)
        self
>>>>>>> 4f58c9071f6f5ad82d6978f634085c5dbdde7283
      end
    end
  end
end

module Enumerable
  include PMap
end

# module Parallel
#   class DeadWorker < Exception
#   end

#   class Break < Exception
#   end

#   class ExceptionWrapper
#     attr_reader :exception
#     def initialize(exception)
#       dumpable = Marshal.dump(exception) rescue nil
#       unless dumpable
#         exception = RuntimeError.new("Undumpable Exception -- #{exception.inspect}")
#       end

#       @exception = exception
#     end
#   end

#   class Worker
#     attr_reader :pid, :read, :write
#     def initialize(read, write, pid)
#       @read, @write, @pid = read, write, pid
#     end

#     def close_pipes
#       read.close
#       write.close
#     end

#     def wait
#       Process.wait(pid)
#     rescue Interrupt
#       # process died
#     end

#     def work(index)
#       begin
#         Marshal.dump(index, write)
#       rescue Errno::EPIPE
#         raise DeadWorker
#       end

#       begin
#         Marshal.load(read)
#       rescue EOFError
#         raise DeadWorker
#       end
#     end
#   end

#   class << self
#     def in_threads(options={:count => 2})
#       count, options = extract_count_from_options(options)

#       out = []
#       threads = []

#       count.times do |i|
#         threads[i] = Thread.new do
#           out[i] = yield(i)
#         end
#       end

#       kill_on_ctrl_c(threads) { wait_for_threads(threads) }

#       out
#     end

#     def in_processes(options = {}, &block)
#       count, options = extract_count_from_options(options)
#       count ||= processor_count
#       map(0...count, options.merge(:in_processes => count), &block)
#     end

#     def each(array, options={}, &block)
#       map(array, options.merge(:preserve_results => false), &block)
#       array
#     end

#     def each_with_index(array, options={}, &block)
#       each(array, options.merge(:with_index => true), &block)
#     end

#     def map(array, options = {}, &block)
#       array = array.to_a # turn Range and other Enumerable-s into an Array

#       if RUBY_PLATFORM =~ /java/ and not options[:in_processes]
#         method = :in_threads
#         size = options[method] || processor_count
#       elsif options[:in_threads]
#         method = :in_threads
#         size = options[method]
#       else
#         method = :in_processes
#         if Process.respond_to?(:fork)
#           size = options[method] || processor_count
#         else
#           $stderr.puts "Warning: Process.fork is not supported by this Ruby"
#           size = 0
#         end
#       end
#       size = [array.size, size].min

#       if size == 0
#         work_direct(array, options, &block)
#       elsif method == :in_threads
#         work_in_threads(array, options.merge(:count => size), &block)
#       else
#         work_in_processes(array, options.merge(:count => size), &block)
#       end
#     end

#     def map_with_index(array, options={}, &block)
#       map(array, options.merge(:with_index => true), &block)
#     end

#     # Number of processors seen by the OS and used for process scheduling.
#     #
#     # * AIX: /usr/sbin/pmcycles (AIX 5+), /usr/sbin/lsdev
#     # * BSD: /sbin/sysctl
#     # * Cygwin: /proc/cpuinfo
#     # * Darwin: /usr/bin/hwprefs, /usr/sbin/sysctl
#     # * HP-UX: /usr/sbin/ioscan
#     # * IRIX: /usr/sbin/sysconf
#     # * Linux: /proc/cpuinfo
#     # * Minix 3+: /proc/cpuinfo
#     # * Solaris: /usr/sbin/psrinfo
#     # * Tru64 UNIX: /usr/sbin/psrinfo
#     # * UnixWare: /usr/sbin/psrinfo
#     #
#     def processor_count
#       @processor_count ||= begin
#         os_name = RbConfig::CONFIG["target_os"]
#         if os_name =~ /mingw|mswin/
#           require 'win32ole'
#           result = WIN32OLE.connect("winmgmts://").ExecQuery(
#               "select NumberOfLogicalProcessors from Win32_Processor")
#           result.to_enum.collect(&:NumberOfLogicalProcessors).reduce(:+)
#         elsif File.readable?("/proc/cpuinfo")
#           IO.read("/proc/cpuinfo").scan(/^processor/).size
#         elsif File.executable?("/usr/bin/hwprefs")
#           IO.popen("/usr/bin/hwprefs thread_count").read.to_i
#         elsif File.executable?("/usr/sbin/psrinfo")
#           IO.popen("/usr/sbin/psrinfo").read.scan(/^.*on-*line/).size
#         elsif File.executable?("/usr/sbin/ioscan")
#           IO.popen("/usr/sbin/ioscan -kC processor") do |out|
#             out.read.scan(/^.*processor/).size
#           end
#         elsif File.executable?("/usr/sbin/pmcycles")
#           IO.popen("/usr/sbin/pmcycles -m").read.count("\n")
#         elsif File.executable?("/usr/sbin/lsdev")
#           IO.popen("/usr/sbin/lsdev -Cc processor -S 1").read.count("\n")
#         elsif File.executable?("/usr/sbin/sysconf") and os_name =~ /irix/i
#           IO.popen("/usr/sbin/sysconf NPROC_ONLN").read.to_i
#         elsif File.executable?("/usr/sbin/sysctl")
#           IO.popen("/usr/sbin/sysctl -n hw.ncpu").read.to_i
#         elsif File.executable?("/sbin/sysctl")
#           IO.popen("/sbin/sysctl -n hw.ncpu").read.to_i
#         else
#           $stderr.puts "Unknown platform: " + RbConfig::CONFIG["target_os"]
#           $stderr.puts "Assuming 1 processor."
#           1
#         end
#       end
#     end

#     # Number of physical processor cores on the current system.
#     #
#     def physical_processor_count
#       @physical_processor_count ||= begin
#         ppc = case RbConfig::CONFIG["target_os"]
#         when /darwin1/
#           IO.popen("/usr/sbin/sysctl -n hw.physicalcpu").read.to_i
#         when /linux/
#           cores = {}  # unique physical ID / core ID combinations
#           phy = 0
#           IO.read("/proc/cpuinfo").scan(/^physical id.*|^core id.*/) do |ln|
#             if ln.start_with?("physical")
#               phy = ln[/\d+/]
#             elsif ln.start_with?("core")
#               cid = phy + ":" + ln[/\d+/]
#               cores[cid] = true if not cores[cid]
#             end
#           end
#           cores.count
#         when /mswin|mingw/
#           require 'win32ole'
#           result_set = WIN32OLE.connect("winmgmts://").ExecQuery(
#               "select NumberOfCores from Win32_Processor")
#           result_set.to_enum.collect(&:NumberOfCores).reduce(:+)
#         else
#           processor_count
#         end
#         # fall back to logical count if physical info is invalid
#         ppc > 0 ? ppc : processor_count
#       end
#     end

#     private

#     def work_direct(array, options)
#       results = []
#       array.each_with_index do |e,i|
#         results << (options[:with_index] ? yield(e,i) : yield(e))
#       end
#       results
#     end

#     def work_in_threads(items, options, &block)
#       results = []
#       current = -1
#       exception = nil

#       in_threads(options[:count]) do
#         # as long as there are more items, work on one of them
#         loop do
#           break if exception

#           index = Thread.exclusive{ current+=1 }
#           break if index >= items.size

#           with_instrumentation items[index], index, options do
#             begin
#               results[index] = call_with_index(items, index, options, &block)
#             rescue Exception => e
#               exception = e
#               break
#             end
#           end
#         end
#       end

#       handle_exception(exception, results)
#     end

#     def work_in_processes(items, options, &blk)
#       workers = create_workers(items, options, &blk)
#       current_index = -1
#       results = []
#       exception = nil
#       kill_on_ctrl_c(workers.map(&:pid)) do
#         in_threads(options[:count]) do |i|
#           worker = workers[i]

#           begin
#             loop do
#               break if exception
#               index = Thread.exclusive{ current_index += 1 }
#               break if index >= items.size

#               output = with_instrumentation items[index], index, options do
#                 worker.work(index)
#               end

#               if ExceptionWrapper === output
#                 exception = output.exception
#               else
#                 results[index] = output
#               end
#             end
#           ensure
#             worker.close_pipes
#             worker.wait # if it goes zombie, rather wait here to be able to debug
#           end
#         end
#       end

#       handle_exception(exception, results)
#     end

#     def create_workers(items, options, &block)
#       workers = []
#       Array.new(options[:count]).each do
#         workers << worker(items, options.merge(:started_workers => workers), &block)
#       end
#       workers
#     end

#     def worker(items, options, &block)
#       # use less memory on REE
#       GC.copy_on_write_friendly = true if GC.respond_to?(:copy_on_write_friendly=)

#       child_read, parent_write = IO.pipe
#       parent_read, child_write = IO.pipe

#       pid = Process.fork do
#         begin
#           options.delete(:started_workers).each(&:close_pipes)

#           parent_write.close
#           parent_read.close

#           process_incoming_jobs(child_read, child_write, items, options, &block)
#         ensure
#           child_read.close
#           child_write.close
#         end
#       end

#       child_read.close
#       child_write.close

#       Worker.new(parent_read, parent_write, pid)
#     end

#     def process_incoming_jobs(read, write, items, options, &block)
#       while !read.eof?
#         index = Marshal.load(read)
#         result = begin
#           call_with_index(items, index, options, &block)
#         rescue Exception => e
#           ExceptionWrapper.new(e)
#         end
#         Marshal.dump(result, write)
#       end
#     end

#     def wait_for_threads(threads)
#       threads.compact.each do |t|
#         begin
#           t.join
#         rescue Interrupt
#           # thread died, do not stop other threads
#         end
#       end
#     end

#     def handle_exception(exception, results)
#       return nil if exception.class == Parallel::Break
#       raise exception if exception
#       results
#     end

#     # options is either a Integer or a Hash with :count
#     def extract_count_from_options(options)
#       if options.is_a?(Hash)
#         count = options[:count]
#       else
#         count = options
#         options = {}
#       end
#       [count, options]
#     end

#     # kill all these pids or threads if user presses Ctrl+c
#     def kill_on_ctrl_c(things)
#       if defined?(@to_be_killed) && @to_be_killed
#         @to_be_killed << things
#       else
#         @to_be_killed = [things]
#         Signal.trap :SIGINT do
#           if @to_be_killed.any?
#             $stderr.puts 'Parallel execution interrupted, exiting ...'
#             @to_be_killed.flatten.compact.each { |thing| kill_that_thing!(thing) }
#           end
#           exit 1 # Quit with 'failed' signal
#         end
#       end
#       yield
#     ensure
#       @to_be_killed.pop # free threads for GC and do not kill pids that could be used for new processes
#     end

#     def kill_that_thing!(thing)
#       if thing.is_a?(Thread)
#         thing.kill
#       else
#         begin
#           Process.kill(:KILL, thing)
#         rescue Errno::ESRCH
#           # some linux systems already automatically killed the children at this point
#           # so we just ignore them not being there
#         end
#       end
#     end

#     def call_with_index(array, index, options, &block)
#       args = [array[index]]
#       args << index if options[:with_index]
#       if options[:preserve_results] == false
#         block.call(*args)
#         nil # avoid GC overhead of passing large results around
#       else
#         block.call(*args)
#       end
#     end

#     def with_instrumentation(item, index, options)
#       on_start = options[:start]
#       on_finish = options[:finish]
#       on_start.call(item, index) if on_start
#       yield
#     ensure
#       on_finish.call(item, index) if on_finish
#     end
#   end
# end

Infect::Runner.call(*ARGV)
